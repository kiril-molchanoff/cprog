
	+--------------+
	|  C  !=  C++  |
	+--------------+



[1]	

	printf() 					- "%|флаги|ширина_поля|.точность|модификатор|спецификатор"
	printf("%+-10.2f", dec)


	scanf() 					- "%|*|ширина_поля|модификатор|спецификатор"
	scanf("%10[^\n]", str);	

	[...]		- считывание только определенных знаков
	[^...]		- считывание вплоть до определенных знаков



[2]

	for ( ; ; ) - можно опустить выражения



[2]		МАССИВ	
		======


	Массив рассматривается особым образом только при применении операторов
		sizeof(arr)		- размер всего массива в байтах
		&arr			- адрес всего массива!

	Во всех остальных случаях массив неявно приводится к соотв. типу указателя &a[0]


	Имя массива arr - неизменяемый указатель (имя выделенного блока памяти)


	запись a[i] ~ *(a + i)	верна всегда - и для массивов, и для указателей
	

	Объявление и инициализация:
	--------------------------

	int a[5];
	int a[5] = { 1, 2, 3, 4, 5 };
	int a[] = { 1, 2, 3, 4, 5 };
	int a[5] = { [1]=1, [3]=3 };
	int a[max_size];				- нельзя инициализировать!!!

	int a[3][2] = { {1, 2}, {3, 4}, {5, 6} }; 	}
	int a[3][2] = { 1, 2, 3, 4, 5, 6 };			} эквивалентны 


	!!! Массивы не инициализируются из выражений. 
	    Справа может стоять только { ... };

			y

		+---+---+
		| 0 | 1 |
		+---+---+
	  x | 2 | 3 |
		+---+---+
		| 4 | 5 |
		+---+---+


	Несмотря на то, что многомерный массив представлен непрерывным блоком ячеек памяти, 
	в каждой ячейке вида a[], a[][], ... хранятся метаданные (длина в байтах, т.п.). По сути, 
	несмотря на линейное представление, он все равно состоит из полноценных массивов


	sizeof(a)			- размер всего [i][j] в байтах
	sizeof(a[i])		- размер [j] в байтах
	sizeof(a[i][j])		- размер . в байтах


	a[i]			~ *(a + i);
	a[i][j] 		~ *(a + i*y + j);
	a[i][j][k]		~ *(a + i*y*z + j*z + k); 
	...

	Поэтому при объявлении массива пустыми могут быть только первые скобки []:

		"declaration of ‘a’ as multidimensional array must have bounds 
		for all dimensions except the first"
													(c) gcc


	Массив нельзя передать в ф-цию по значению, только в виде указателя на 1-й эл.
	(array-to-pointer decay) 

	В параметрах ф-ции: 			a[] ~ *a 		(лучшая читаемость)


	Способы передачи массива в ф-цию:
	--------------------------------

	foo	(int *a, 	size_t n)
	foo	(int a[], 	size_t n)
	foo	(int a[5],	size_t n)			- a содержит min 5 эл.
	foo (size_t n,	int a[static n])	- !!! variable length arr (VLA) как параметр - min n эл.
	

	Запись int a[static n] в параметрах даёт компилятору дополнительную информацию:

		* a указывает минимум на n * sizeof(int) байт,
		* обращения a[i] для i < n корректны,
		* a != NULL

	n в квадратных скобках в параметрах функции не влияет на тип,
	но влияет на сигнатуру ф-ции, читаемость и анализ кода.
	(своего рода контракт, но не механизм)



	Указатель на массив:
	-------------------

	int *p = a; 			- указывает на a[0]
	int (*p)[] = &a;		- указывает на весь массив как объект


	int * name [10]			- массив (name) из эл. типа (int *)
	int (*name)[10]			- (* name) типа массив из эл. типа (int [10])


	ptr[i]			~ *(ptr + i)
	ptr[i][j]		~ *(*(ptr + i) + j)
	ptr[i][j][k]	~ *(*(*(ptr + i) + j) + k)

		Индексация ~ смещение указателя + разыменовывание


	! ВАЖНО !

	Указатель на массив — инструмент для структурированной памяти.
	Для линейных данных он почти всегда уступает указателю на элемент.



[]		СТРОКИ
		======


	Строка = массив <char>, заканчивающийся '\0'


	1) char s_arr[] = "abc";	// строка как массив - 
									создается новый массив и инициализируется
									значениями { 'a', 'b', 'c', '\0' }. По сути происходит
									копирование в массив

	2) char  *s_ptr = "abc";	// строка как указатель - 
									создается новый указатель на первый эл. строкового литерала 
									(неизменяемый массив, время жизни -	до завершения программы). 
									Поэтому изменение *s_ptr -> UB!!!

	(1) - массив  !=  (2) - указатель




	Строковые литералы:
	------------------

	Строковой литерал - анонимный неизменяемый массив char[] со 
		статическим временем жизни. Оканчивается на '\0'.


		"Если строка char[] инициализируется строковым литералом, компилятор разворачивает 
		литерал в список символов."
											(с) спецификация С


	char a[] = "hello"; 	// -->  { 'h','e','l','l','o','\0' }


	! ИНТЕРНИРОВАНИЕ СТРОК !  (.rodata)



[5]		УКАЗАТЕЛИ
		=========


	Арифметика указателей:
	---------------------
	
	ptr +/- n 					- n * sizeof(*ptr)
	ptrdiff_t d = (ptr1-ptr2) 	- разница в байтах / sizeof типа указателя


	Указатель на константу Vs Неизменяемый указатель
	------------------------------------------------

		Указатель на константу:		const <type> * ptr;
		Неизменяемый указатель: 	<type> * const ptr;
									   	   ^ ~~~~~			(всегда относится к предыдущему)

	void *
	------

		Для (void *) не определена арифметика - это неполный тип. Поэтому его нужно сначала
		привести к необходимому. типу


	NULL
	----

		Целочисленная константа, обозначающая пустой указатель (адрес 0x0...0)



[]		ДЕМИСТИФИКАЦИЯ  *, [], ()
		=========================
	
	






[]		ФУНКЦИИ И ОБЛАСТЬ ВИДИМОСТИ
		===========================


	В сигнатуре ф-ции без параметров при ее объявлении и определении 
	нужно использовать (void) !!!

		int foo(void);		// объявление
		int foo(void) {}	// определение
			x
		foo();				// вызов




	STORAGE CLASS - Класс хранения
	-------------
		
		[ auto ]		// нет!
		[ extern ]
		[ static ]
		[ register ] 	// нет!


		[auto]
		------
			Класс по умолчанию для всех локальных переменных

			* Область видимости		- ограничена блоком кода
			* Жизненный цикл		- от входа до выхода
			* Инициализация			- (неявно мусор)

		[extern]
		--------
			Объявление глобальной переменной или ф-ции, что определены в другом файле .c.
			"этот объект существует и будет доступен на этапе линковки"

			* Область видимости		- глобальная
			* Жизненный цикл		- все время выполнения программы
			* Инициализация			- строго там же, где объявлена (неявно 0)

		[static]
		--------
			Имеет 2 применения 

		(1)	Локальные переменные -	гарантирует статическое время хранения

			* Область видимости		- локальная (как у auto)
			* Жизненный цикл		- все время выполнения программы (не только внутри блока)
			* Инициализация			- только один раз при первом выполнении блока (неявно 0)
	
			Память выделяется до выполнения программы и сохраняется вплоть до конца.	
			Инициализация происходит до выполнения, так что сам инициализатор должен
			быть константным (не runtime)


		(2)	Глобальные переменные и функции - ограничение области видимости текущим файлом

			* Область видимости		- строго текущий файл
			* Жизненный цикл		- все время выполнения программы

			> имя не экспортируется линковщику
			> другой .c файл не может к нему обратиться через extern

		Такая инкапсуляция полезна для сокрытия деталей реализации модуля



	Указатель на ф-цию
	------------------


		В C ф-ция тоже имеет свой адрес - адрес первого байта в памяти, по которому 
										  располагается выполняемый код ф-ции

		Самый распростаненный указатель на ф-цию - ее имя 
		(как и у массива, чье имя - неизменяемый указатель на 1-й эл.)

		
		int (*name)(int, int)		- указатель на ф-цию сигнатуры "int (int, int)"
		int * name (int, int)		- объявление ф-ции сигнатуры "int* (int, int)" 


		foo - это функция (имя, по которому к ней можно обратиться)
		&foo - указатель на функцию (содержит адрес ее кода в памяти)

		в выражениях foo неявно превращается в foo ~ &foo (кроме sizeof и &foo)
	

		foo() ~ (&foo)() ~ (*foo)()	

		!ВАЖНО!
		------
		В C оператор вызова функции () требует выражение, которое имеет тип
			ИЛИ функции					- (*&foo)() разыменование
			ИЛИ указателя на функцию 	- (&foo)()	адрес



	Для лучшей читабельности рекомендуется определять свои типы сигнатур ф-ций, если
	они становятся слишком громоздкими (!!!)

	typedef  int foo_f (int, int);


	В параметрах функции допускается упрощенный "функциональный" синтаксис:

		void foo (int (*bar)(int));
		void foo (int bar(int));		// эквивалентно

	но как и в случае массивов

		void foo (int *a);
		void foo (int a[]);				// эквивалентно
		
	это не более, чем красивая запись, которая все равно неявно приводится к указателю.
	Более того, она разрешена только для параметров.


	
	Переменное кол-во параметров:
	----------------------------

	C допускает использование ф-ций, что имеют нефиксированное число параметров. Более того,
	даже тип параметров может быть неизвестен, точная сигнатура становится известной только во
	время вызова ф-ции.

	void foo (size_t cnt, ...) {}

		> ... - дальше идут дополнительные аргументы
		> первым параметром обычно передают кол-во аргументов и/или способ определить их тип,
			т.к C не хранит такую информацию

	Для упрощения работы с переменным кол-вом параметров неопределенных типов существует 
	стандартный заголовочный файл "stdarg.h"

	В нем определены специальные тип и макро-команды:

		va_list										- указатель на текущий аргумент

		va_start (va_list ap, last_fixed_arg);		- установка указателя на первый арг. ...
		va_arg (va_list ap, type);					- получает арг. и смещает указатель
		va_end (va_list ap);						- освобождает ресурсы


	Правильный шаблон всегда такой:

		va_list ap;
		va_start(ap, last);
			...
		va_end(ap);



	Параметры командной строки:
	--------------------------


	void main (int argc, const char **argv)



[]		ТИПЫ ДАННЫХ
		===========


	typedef:
	-------

	typedef объявляет псевдоним типа.
	Причем это происходит по тем же правилам, что и объявление/определение переменной этого 
	типа. По сути, имя такой переменной становится именем типа, а не именем объекта.

	typedef не "упрощает тип", он фиксирует результат сложного объявления под одним именем.

	Поэтому:
		– typedef с указателями часто сбивает с толку,
		– const относится к typedef-имени типа, а не к скрытому за ним типу,
		– чтение typedef надо делать тем же алгоритмом, что и чтение обычных объявлений C

	Этим он отличается от #define: определяет новый тип, а не просто подставляет текст



	!!! ВАЖНО !!!
	~~~~~~~~~~~~~

	>>	int *p;				*
		------
		
		* не принадлежит типу int. Она принадлежит декларатору p. Читается:
			(*p) - типа int

		То есть, разыменование p дает тип int   <=>   p - указатель на int


	>>	int a[10];			[]
		---------

		[] относится не к типу int, а к декларатору a. Читается:					
			a[i] - типа int

		То есть, i-й эл. a - int   <=>   a - массив[10] типа int
		

	>>  int f(int);			()
		----------

		() относится не к типу int, а к декларатору f. Читается:
			f(n) - типа int

		То есть, результат f(n) - int   <=>   a - ф-ция "int (int)"


	Приоритет операторов:	() = [] > *
	--------------------


	ПРАВИЛО ЧТЕНИЯ ТИПОВ:
	--------------------

	В C имя — это центр типа. Всё остальное "обвешивается" вокруг него.
	Тип не идет слева --> направо, но строится вокруг идентификатора (имени)
		



	Примеры:
	-------

	int (*p) (int);				// ptr to func "int (int)"
	int (*a[4]) (int);			// arr[4] of ptr to func "int (int)"
    int* (*a[4]) (int);			// arr[4] of ptr to func "int* (int)"

    int *(**p) (int);			// ptr to ptr to func "int* (int)"
    int *(*(*p)[4]) (int);		// ptr to arr[4] of ptr to func "int* (int)"


    int (*p)[4];				// ptr to arr[4] of int
    int (*a[3])[4];				// arr[3] of ptr to arr[4] of int
    int	*a[3][4];				// arr[3] of arr[4] of ptr to int*


    int *(*a[3])[4];			// arr[3] of ptr to arr[4] of ptr to int



	size_t:
	------

	Данный тип представляет объекты, тесно связанные с размерами в памяти.

	Применение:
	* результат sizeof
	* размер массива
	* кол-во байтов для аллокации, копирования, чтения и записи
	* индексы и смещения


	
	const:
	-----

	Модификатор const - "запрещено изменять через это имя после инициализации".
	Не "константа компиляции". Компилятор не обязан знать значение const-поля на этапе 
	компиляции и не обязан встраивать его как число (это уже #define).

	const-поле не является настоящей константой в смысле C. Его нельзя использовать, например, 
	для задания размера массива




[9]		ТРУКТУРЫ И ОБЪЕДИНЕНИЯ
		=======================


	Структура - составной тип данных, состоящий из других компонентов различных типов.


	Объявление:
	----------

	struct person;		- неполный тип, размер неизвестен


	Определение:
	-----------

	struct person {
		const char *name;
		int age;
	};

	Объявление + определение
	Все элементы объявляются как обычные переменные, но для них пока не выделяется память
	и их нельзя инициализировать. Мы просто определяем новый (составной) тип.
	Структуру нельзя определить больше 1 раза


	Пока структура не определена, мы не можем полноценно ее использовать.
	Единственный сценарий использования неполного типа - определение указателя на него



	Определение объекта структуры:
	-----------------------------

	struct person p1;		- выделение памяти под объект, размер должен быть известен

	
	typedef struct Person {		// Определение struct Person и (!) псевдонима Person для него
		const char *name;
		int age;
	} Person;					- "определение переменной", она и становится именем типа

	...

	Person p1 = {"Bob", 34};
	struct Person p2 = {"Tom", 22};
	p1 = p2								// struct Person и Person - один тип

	

	Анонимные структуры:
	-------------------

	мы также можем не указывать название структуры. В таком случае мы не сможем создавать
	на ее основе новые объекты, кроме уже определенных


	struct {
		const char *name;
		int age;
	} tom, paul = { "Paul", 19 };



	struct { int n; } num1 = { 1 };
	struct { int n; } num1 = { 2 };

	num1 = num2;		// - ошибка, разные типы !!!


	Каждый раз, когда компилятор видит объявление структуры, он создаёт новый, 
	уникальный тип, даже если секунду назад видел абсолютно такой же текст.

	Использование макросов и #define в контексте структур - плохая идея !!!


	Структура	- значимый тип,		язык умеет копировать её как целое.
	Массив		- не значимый тип,	язык никогда не копирует массив как целое.

	Структура - "пакет значений". Массив - "кусок памяти".



	Инициализация объекта структуры:
	-------------------------------

	struct person p1 = { "Tom", 23, foo(6) };		- позиционная (в порядке определения)
	struct person p1 = { .age=23, .name="Tom"};		- именованная






	Указатель на структуру:
	----------------------

	Структура - значимый тип, но на нее существуют указатели. 

	Случаи применения:
		* передача структур в ф-цию (по ссылке)
		* если порядок определения структур непозволяет объявить объект структуры
			(напр, в больших библиотеках или рекурсивном определении), 
			то вместо объекта неполного типа объявляют объект - указатель на структуру

			struct A {
				struct B *b;
			};

			struct B {
				struct A *a;
			};



	Представление структур в памяти:
	-------------------------------

	Поля структуры появляются в памяти в порядке определения. Первое поле имеет тот же адрес, 
	что и структура в целом (адрес объекта структуры = указатель на первое поле)

	При размещении полей структуры учитывается выравнивание этих полей. Это значит, что поле 
	должно располагаться по адресу, кратному размеру самого поля.

	Размер структуры дополняется так, чтобы он был кратен max выравниванию среди ее полей


	struct A {
		int8_t i8;
		int32_t i32_a2[2];
		int8_t i8_a5[5];
	};

	| i8     | off    | i32_a2  | i8_a5    | off
	-------------------------------------------------
	| [0,1)  | [1,4)  | [4,12)  | [12,17)  | [17,20) 

		  _____                            
	| 0 | 1 2 3 | 4 5 6 7 , 8 9 10 11 | 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 |


	Оптимизация расположения !!!
	------------------------

	Распространенный принцип определения полей структуры: чередование полей с большим и
	меньшим выравниваем. Это позволяет более экономно распределить память и 
	уменьшить размер структуры



[]		ЛИТЕРАЛЫ:
		======== 


	Обычный литерал:
	---------------
	
	Обычные литералы соответствуют скалярным типам:

		целочисленный:	42			(int)
		вещественный:	3.1415		(double)
		символьный:		'A'			(char)
		нуль-ptr:		NULL		(size_t)	- #define
		логический:		true		(_Bool)		- #define
		строковой:		"hello"		(char[])	- особый случай

	У обычного литерала нет имени, только тип и собственно значение.

	Обычный литерал - именно значение, не полноценный объект (кроме строкового).
	У него нет выделенной под него памяти, он просто вычисляется на ходу
	

	Составной литерал:
	-----------------

	(Person){ "tom", 23, foo(6) }


	Составные литералы существуют в первую очередь для агрегатов:
		* массивов
		* струкутр
		* объединений
	
	Их задача - создание объекта составного типа "на месте". Происходит создание безымянного
	объекта сразу с инициализацией.
	
	Врямя жизни составного литерала зависит от контекста:
		* внутри блока кода		- автоматическое
		* на уровне файла		- статическое

	Составной литерал - не временное значение. Это самый настоящий объект, только без имени.
	Под него выделяется память, в которой он хранится.

	
	! ВАЖНО !
	~~~~~~~~~

	Составные литералы не ограничиваются только агрегатами. Они могут создавать любой
	объектный тип, включая скалярные:
		
		(int){42}	- корректно



[]		ПЕРЕЧИСЛЕНИЯ:
		============

	Перечисление - тип данных, который содержит набор целочисленных костант, каждой из 
	которых соопоставлено определенное числовое значение.

	По сути, это именованные константы, собранные в одну смысловую группу.

		enum Color {
			RED = 1,
			GREEN,
			BLUE
		};

	В C перечисления не являются отдельно существующим типом значений, они тесно связаны с int.
	Объект типа enum - по сути, объект int (размер может отличаться)


	Стандарт C требует, чтобы объявление enum всегда содержало его определение


	Область видимости:
	-----------------

		Перечислители (именные константы) имеют ту же область видимости, где объявлен enum.
		Это частая причина конфликтов имен.

		enum A { X, Y };
		enum B { X, Y };	// ошибка: константа X уже определена


	Ограничения:
	-----------
		* нет строгой типобезопасности
		* нет проверки допустимых значений


	"enum в C - это int, к которому прицепили смысл и имена"
																(c) ChatGPT-5.2
 


[]		ОБЪЕДИНЕНИЯ:
		===========

	Объединение в C - составной тип данных, в котором все поля занимают одну и ту же
	область памяти.

		union A {
			int32_t i;		// 4 байта
			char c;			// 1 байт
			double d;		// 8 байт
		};

			[] [] [] [] [] [] [] []		<- область памяти
		i:	-----------
		c:	--
		d:	-----------------------


	Размер объединения = размер наибольшего поля.
	В общем случае допустимо читать только тот член union, который был записан последним.

	
	Примение:
	--------

	Причины можно свести к 3-м группам:
		* память
		* представление данных
		* низкоуровневый интерфейс


	(1) Экономия памяти:
		---------------
	
	Если объект всегда находится в одном из нескольких взаимоисключающих состояний.
	В таком случае это так называемый tagged union - важная идиома C.

		struct Value {
			enum { 
				V_UINT32, 
				V_DOUBLE 
			} tag;				// описание состояния

			union { 
				uint32_t ui32;
				double d;
			} data;				// значение
		};	

	Без union пришлось бы хранить uint32 и double одновременно, даже если используется 
	только одно из них.


	(2)	Разное представление одной памяти:
	    ---------------------------------
	
	union {
		uint32_t mask;
		uint8_t	bytes[];
	} x;

	Позволяет разбирать сетевые пакеты, маски, bitset'ы и многое другое


	! ВАЖНО !
	~~~~~~~~~

	Нужно быть осторожным: чтение поля, отличного от последнего записанного, ограничено 
	правилами строгого алиасинга.

		Разрешённые случаи:
		------------------
		> unsigned char  (по байтам)
		> общие начальные члены
		> типы с совместимым представлением




[]		БИТОВЫЕ ПОЛЯ:
		============

	Битовые поля обеспечивают удобный доступ к отдельным битам данных. Они позволяют создавать
	объекты, чей размер некратен байту.

	Битовое поле может существовать только внутри структуры/объединения.

		struct Point {
			unsigned int x : 5;
			unsigned int y : 3;
		};

	Порядок битовых полей в памяти строго не определен и зависит от имплементации !!!




[]		О ВАЖНОМ ...
		============

	Обобщенность:
	------------

	В C нет параметрических типов в духе C++ templates или C# generics. 

	Зато есть примитивы:
		> void *	- указатель "на что-то" 		(неизвестно что)
		> union		- значение "одного из" полей 	(неизвестно какое)

	Любая "обобщённость" в C - это паттерн, а не языковая конструкция.


	Функции как "виртуальные методы"

		typedef struct {
			void (*print)(const void *);
			void (*destroy)(void *);
		} VTable;


		typedef struct {
			const VTable *vtable;
			union {
				int i;
				double d;
			} data;
		} Object;

	Это уже почти объектная модель. Так написаны половина библиотек на C. 
	Union здесь используется для хранения данных, а поведение реализуется через таблицы ф-ций.



[]		УПРАВЛЕНИЕ ПАМЯТЬЮ:
		==================

	
	Статическая  vs  Динамическая:		(Сравнение)
	-----------------------------


	(1) Выражаемое намерение:
		~~~~~~~~~~~~~~~~~~~~
		Статическая - "Объект имеет чёткую роль в структуре программы, которую диктует синтаксис".
		Динамическая - "Объект живёт по логике алгоритма, а не по форме кода".


	(2) Копирование и семантика значений:
		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		* Статически определенные объекты легко копируются как значения. 
		* Динамические почти всегда требуют копирования через указатели, а значит - продуманной
			семантики владения. (Кто освобождает? Когда? etc.)


	(3) Размер аллокации:
		~~~~~~~~~~~~~~~~
		* Статическая память требует размера, известного во время компиляции. 
		* Динамическая позволяет выбирать размер во время выполнения.


	(4) Инициализация:
	    ~~~~~~~~~~~~~
		* Статические объекты инициализируются нулями автоматически. 
		* Динамическая аллокация даёт сырую память с мусором.


	(5) Расположение и локальность:
	    ~~~~~~~~~~~~~~~~~~~~~~~~~~
		* Стек обычно очень быстрый и хорошо кэшируется. 
		* Куча более фрагментированная, медленнее, и её доступ хуже предсказуем для процессора.


	(6)	Лимиты:
	    ~~~~~~
		* Стек ограничен и обычно сравнительно мал. Его переполнение - мгновенная ошибка.
		* Куча может быть многим больше, но и malloc может вернуть NULL.


	(7) Оптимизации:
		~~~~~~~~~~~
		* Статическая память лучше понятна компилятору и потому поддается оптимизации.
		* Куча - чёрный ящик, malloc - почти что барьер оптимизаций.


	(8) Потоки:
		~~~~~~
		* Стек у каждого потока свой. 
		* Куча обычно общая и требует синхронизации.


	Это разные способы мыслить о данных. В хорошем C-коде куча используется не потому, что так
	гибче, а потому что иначе невозможно выразить нужное время жизни или структуру данных.



	Динамическая аллокация:
	----------------------

	Для управления динамическим выделением памяти используются ф-ции из "stdlib.h":

	void *malloc	(size_t size);				- выделение size байт сырой памяти
	void *calloc	(size_t num, size_t size);	- выделение блока [num] по size байт пустой памяти
	void *realloc	(void *ptr, size_t size);	- реаллокация ptr с новым размером size байт
	void free		(void *ptr);				- освобождение выделенной памяти

	
	Важно проверять результат malloc/calloc/realloc на NULL:
	
		cosnt size_t n = 7;
		int16_t *a = calloc(n, sizeof(*a));
		if (a == NULL)
			...

	После free() следует устранять висячие указатели на освобожденную память:
		
		free(vp);
		vp = NULL;


	memset, memcpy, memmove
	-----------------------
		
		Очень полезные ф-ции, которые являются частью стандарта. 

		void *memset (void *dest, int n, size_t cnt)				- set 'cnt' bytes
		void *memcpy (void *dest, cosnt void *src, size_t cnt)		- copy 'cnt' bytes
		int   memcmp (const void *l, const void *r, size_t cnt)		- cmp 'cnt' bytes 

	

[]		ОРГАНИЗАЦИЯ ПАМЯТИ ПРОГРАММЫ. СТРУКТУРА СЕГМЕНТОВ
		=================================================

	Стандарт C не описывает сегменты памяти напрямую. Он говорит про время жизни объектов и 
	области хранения. Деление на сегменты - модель, которая сложилась из ABI, линкеров и ОС. 
	Но ввиду устойчивости ее можно считать стандартом.

	Модель состоит в организации различных типов данных и кода в отдельные 
	сегменты в адресном пространстве процесса. 
	Каждый сегмент имеет свое применение и обладает уникальными хар-ками, которые определяют
	распределение, доступ и управление памятью во время выполнения программы.


	[ text/code ]
	[ rodata    ]
	[ data      ]
	[ bss       ]
	[ heap      ]
	[ stack     ]


	СЕГМЕНТ КОДА:		(CODE)
	~=~=~=~=~=~=~

		Содержит скомпилированные машинные инструкции для всех ф-ций программы. Обычно помечен
		как readonly, executable.

		В C ф-ция не является объектом, есть только ее адрес.


	СЕГМЕНТ READONLY ДАННЫХ:		(RODATA)
	~=~=~=~=~=~=~=~=~=~=~=~

		Хранит константы времени компиляции:
			* const объекты
			* строковые литералы
				...
	

	СЕГМЕНТ ИНИЦИАЛ. ГЛОБАЛЬНЫХ ДАННЫХ: 		(DATA)
	~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=

		Содержит объекты, существующие на протяжении всего выполнения программы, что имеют
		явную инициализацию.


	СЕГМЕНТ НЕИНИЦИАЛ. ГЛОБАЛЬНЫХ ДАННЫХ: 		(BSS)
	~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=

		Содержит объекты, существующие на протяжении всего выполнения программы, что не были
		явно инициализированы.

		Они формально инициализированы нулем, но практически их нет изначально, память выделяется
		во время исполнения. Т.е. BSS изначально пуст и не влияет на размер исполняемого файла, но
		влияет на протребление памяти во время runtime


	СЕГМЕНТ КУЧИ:		(HEAP)
	~=~=~=~=~=~=~

	Предоставляет динамическую память, что управляется программой. Позволяет программе 
	запрашивать	память во время выполнения. Располагается под стеком, растет вверх.

		* время жизни объектов контролируется программистом
		* общий сегмент для всей программы


	СЕГМЕНТ СТЕКА:		(STACK)
	~=~=~=~=~=~=~

	Содержит автоматические объекты ф-ций.

	При каждом вызове ф-ции создается новый фрейм стека, который хранит ее локальные данные.
	Располагается в верхней части структуры памяти, растет вниз.

	Стек работает по принципу last-in-first-out (LIFO), автоматически управляя
		выделением памяти 		(вызов ф-ции)
		освобождением памяти 	(выход из ф-ции)

	Такое автоматическое управление памятью делает его эффективным для временного хранения данных,
	но ограничивает время жизни переменных их областью видимости.



	Время жизни vs сегменты:
	-----------------------

	C мыслит не сегментами, а временем жизни:

		> автоматическое	(stack)
		> статическое		(rodata/data/bss)
		> динамическое		(heap)

	Сегменты памяти - реализация этой модели на уровне ОС.


	УТИЛИТЫ:
	-------

		* gdb (GNU debugger)	- динамический
		* objdump				- статичский



[] 		ПРЕПРОЦЕССОР
		============


	Процесс компиляции на C состоит из этапов:

		1) Препроцессинг	(.c -> .c)
		2) Компиляция		(.c -> .o)
		3) Линковка			(.o	-> .exe)

	Препроцессор обрабатывает исходный код программы до непосредственной компиляции, результат
	посылается дальше на компиляцию.


	Для управления препроцессором применяются директивы. 

		#define		- определение макроса / идентификатора
		#undef		- отменение определения макроса / идентификатора
		#ifdef		- определен ли идентификатор
		#ifndef		- не определен ли идентификатор

		#include	- вставляет текст из файла

		#if			- условная конструкция if
		#elif		
		#else		
		#endif		

		#line		- меняет номер следующей строки
		#error		- формирует текст ошибки трансляции
		#pragma		- определяет действия для компилятора (зависят от реализации)

	

	#include:
	--------

		Вставка текста из файла:

		#include <...>	- из стандартного каталога C
		#include "..."	- путь к файлу (полный / текущий каталог)


	#define:
	-------
		
		Опредяет идентификатор и последовательность символов, что будет подставляться 
		вместо индентификатора при каждом обращении. Идентификатор еще называют процессорным
		символом.

		#define "identifier" "sequence"

		Примеры:

			#define DEBUG				- пустой идентификатор (напр, для #ifdef)
			#define MAX_CNT 1<<4		- псевдоним для константного выражения (массивы!)
			#define ADD(x, y) (x + y)	- макрос с параметрами


		Все идентификаторы, которые предполагают замену на определенную последовательность 
		символов, еще называют макросами.

		Для параметров макросов определены 2 операции:
			#n			- строковое представление операнда
			a##b##c		- объединение лексем


		!!! ВАЖНО !!!
		~~~~~~~~~~~~~

			Используй макросы в коде по минимуму. Это нередко ломает всю логику языка и программы





	ВСТРОЕННЫЕ ЗАГОЛОВОЧНЫЕ ФАЙЛЫ:
	-----------------------------	
	
	assert.h		- тестирование и отладка
	errno.h			- работа с ошибками
	signal.h		- обработка исключений

	stdbool.h		- работа с bool
	stdint.h		- работа с int
	float.h			- работа с float
	ctype.h			- ф-ции для char

	limits.h		- предельные значения типов

	string.h		- ф-ции строк
	math.h			- математика
	complex.h		- математика комплексных чисел
	tgmath.h		- вся математика

	stdarg.h		- переменное кол-во параметров
	stdio.h			- ввод/вывод
	stdlib.h		- память
	stddef.h		- вспомагательные типы

	threads.h		- потоки
	time.h			- дата и время
	locale.h		- локализация



[]		ОБОБЩЕНИЯ. МАКРОС _Generic
		==========================

